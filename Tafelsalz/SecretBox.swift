import libsodium

public class SecretBox {

	public struct SecretKey {

		static let SizeInBytes = PInt(libsodium.crypto_secretbox_keybytes())

		public let bytes: Data

		/**
			Generates a new cryptographically secure random key.
		**/
		public init?() {
			guard let random = Random() else {
				return nil
			}
			self.bytes = random.bytes(count: SecretKey.SizeInBytes)
		}

		/**
			`bytes` comes from an external source and it cannot be validated if
			it is a valid key, i.e. originally generated by a cryptographically
			secure random generator. But this is required for persisting secret
			keys.
		**/
		public init?(withBytes bytes: Data) {
			guard bytes.count == Int(SecretKey.SizeInBytes) else {
				return nil
			}
			self.bytes = bytes
		}
	}

	static let SizeOfNonceInBytes = PInt(libsodium.crypto_secretbox_noncebytes())
	static let SizeOfMacInBytes = PInt(libsodium.crypto_secretbox_macbytes())

	private let secretKey: SecretKey

	public init?() {
		if !Tafelsalz.isInitialized() {
			return nil
		}

		// Generate secret key
		guard let secretKey = SecretKey() else {
			return nil
		}
		self.secretKey = secretKey
	}

	public func encrypt(data plaintext: Data) -> EncryptedData? {
		guard let random = Random() else {
			return nil
		}

		let nonce = random.bytes(count: SecretBox.SizeOfNonceInBytes)

		var authenticatedCiphertext = Data(count: plaintext.count + Int(SecretBox.SizeOfMacInBytes))

		let successfullyEncrypted = authenticatedCiphertext.withUnsafeMutableBytes {
			authenticatedCiphertextPtr in

			return plaintext.withUnsafeBytes {
				plaintextPtr in

				return nonce.withUnsafeBytes {
					noncePtr in

					return self.secretKey.bytes.withUnsafeBytes {
						secretKeyPtr in

						return libsodium.crypto_secretbox_easy(
							authenticatedCiphertextPtr,
							plaintextPtr,
							UInt64(plaintext.count),
							noncePtr,
							secretKeyPtr
						) == 0
					}
				}
			}
		}

		guard successfullyEncrypted else {
			return nil
		}

		var nonceAndAuthenticatedCiphertext = nonce
		nonceAndAuthenticatedCiphertext.append(authenticatedCiphertext)
		return EncryptedData(nonceAndAuthenticatedCiphertext)
	}

	public func decrypt(data nonceAndAuthenticatedCiphertext: EncryptedData) -> Data? {
		guard nonceAndAuthenticatedCiphertext.data.count > Int(SecretBox.SizeOfMacInBytes + SecretBox.SizeOfNonceInBytes) else {
			return nil
		}

		let nonce = nonceAndAuthenticatedCiphertext.data.subdata(in:
			0..<Int(SecretBox.SizeOfNonceInBytes)
		)
		let authenticatedCiphertext = nonceAndAuthenticatedCiphertext.data.subdata(in:
			Int(SecretBox.SizeOfNonceInBytes)..<nonceAndAuthenticatedCiphertext.data.count
		)

		var plaintext = Data(count: authenticatedCiphertext.count - Int(SecretBox.SizeOfMacInBytes))

		let successfullyDecrypted = plaintext.withUnsafeMutableBytes {
			plaintextPtr in

			return authenticatedCiphertext.withUnsafeBytes {
				authenticatedCiphertextPtr in

				return nonce.withUnsafeBytes {
					noncePtr in

					return self.secretKey.bytes.withUnsafeBytes {
						secretKeyPtr in

						return libsodium.crypto_secretbox_open_easy(
							plaintextPtr,
							authenticatedCiphertextPtr,
							UInt64(authenticatedCiphertext.count),
							noncePtr,
							secretKeyPtr
						) == 0
					}
				}
			}
		}

		return successfullyDecrypted ? plaintext : nil
	}
}
